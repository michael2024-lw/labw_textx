# Пример реализации DSL

## Что делаем

Создаем свой "малый" язык программирования для решения определенного круга задач. Такие языки называют еще Domain Specific Language (DSL). Есть более строгое определение, см. лекции.

## Подготовка

Нам потребуется
  - python3
  - textX (``pip install textX``)
  - graphviz (проверить наличие, желательно)

## Задача 1 (1 балл)

Сделаем Hello world! Из документации к [``textX``](http://textx.github.io/textX/stable/tutorials/hello_world/).
Хотим получить приветствия на выходе для каждого участника. Примерно так:

```
Hello World!
Hello Universe!
```

1. Изучаем, как создавать [грамматику](http://textx.github.io/textX/stable/grammar/). 
2. Смотрим [пример грамматики](./hello.tx)
3. Построим диаграмму метамодели (модели созданного языка) из грамматики: - :white_check_mark:

```
$ textx generate hello.tx --target dot
$ dot -Tpng hello.dot -o hello.png
```

4. Теперь пишем пример "программы" на нашем DSL. [Текст здесь](./example.hello)
5. И нам нужен интерпретатор модели, который сможет ее выполнить. Он простой, делаем на python, код есть [здесь](./hello.py). Обратите внимание на импорты из ``textx`` и как загружать модель.
6. Далее запускаем интерпетатор - :white_check_mark:

```
$ python hello.py
```

## Задача 2 (5 баллов)

DSL для управления роботом Karel. Управляет небольшим роботом на плоской доске в клетку со стенками и маяками. Назван в честь автора пьесы про андроидов из 1920-х годов.

Мы будем использовать реализацию самого робота на python, найденную [здесь](https://github.com/xsebek/karel) и исправленную уже в [проекте](./karel_robot)

Создадим что-то похожее на вот это [описание](http://mormegil.wz.cz/prog/karel/prog_doc.htm):

### Задание 1 (1 балл)

Начнем с последовательного исполнения команд ``move``, ``turn``, ``exit``, ``beeper``. Пример грамматики [здесь](./karel-plain.tx). 
   
 - Какие команды определены, есть ли у них параметры? 
 > exit, turn, move, beeper
 - Какие ключевые слова есть в языке? - 
 > begin, end, exit, turn, move, beeper, left, right, pick, put
 - Напишите программу, которая передвигает робота на 2 клетки вперед и на 2 направо - :white_check_mark:
 - Какие соглашения используются для токенизации? 
 > одна команда - одна строка; пробел - разделитель для слов; не больше 2 слов на 1 строке

### Задание 2 (1 балл)

Сделаем интерпретатор. Проще всего сделать отдельный класс для него, экземпляры которого будут хранить состояние исполнения программы. В нашем случае ``karel_robot`` хранит состояние глобально, поэтому это не существенно.

Реализуйте методы выполнения программы на DSL ``interpret(self, model)`` и j,обработки отдельной команды ``process_command(self, c)`` в классе интерпретатора.

Для использования визуализации и уже готовых команд импортируйте все из ``karel_robot.run``. [Пример реализации.](./karel_plain.py)

 - Какой способ реализации мы здесь применяем? - локальная машина состояний. 
 > глобальных циклов состояний парсинга нет, локальное состояние определяется тем, какой условный блок сработал. textx выполняет токенизацию и парсинг, после чего блоки обрабатываются функциями класса Robot. Состояние state-машины определяется содержимым стека (тем, какая функция сейчас читает следующий токен)
 - Подойдут ли здесь какие-либо паттерны проектирования? 
 > в целом да. подойдут многие "реактивные" ("event-based") паттерны. Подойдёт event-loop. Если говорить об общепринятых шаблонах - то точно подойдёт "Состояние".
 - Как вы проверяете, что обрабатываемый узел модели имеет определенный тип из метамодели языка? 
 > При помощи проверки имени класса python (реализовано как оператор `is_`). 

Проверьте, что все работает как надо, запустив интерпретатор. Должна появится текстовая картинка, по которой ходит робот. - :white_check_mark:

```
$ python karel_plain.py
```

### Задание 3 (3 балла)

Добавим в наш язык логические выражения для проверки положения и направления робота: ``north``, ``south``, ``east``, ``west``; определения есть ли стена, маяк или сокровище напротив ``front_is_blocked``, ``is_beeper``, ``front_is_treasure``; а также логические операции ``not``, ``or``, ``and``.

 - Как указать приоритет ``and`` над ``or``? И ``not`` над ними обоими? 
 > при помощи порядка их объявления, кто раньше - тот и приоритетнее (Ordered choice).

Теперь добавим условные конструкции ``if-then-else`` и ``while``. Можно еще добавить повторение ``n`` раз. Пример реализации [здесь](./karel-control.tx)

 - Выясните, в чем состоит проблема dangling-else, как она решается в нашем случае в textx? 
 > неоднозначность, образующаяся когда грамматика допускает неявное формирование исполнительных блоков для if и else (т.е. без begin/end) в сочетании с необязательностью наличия в условной конструкции else. Вданном случае решается путём "join if possible" - else будет присоединён к текущему обрабатываемому if как его часть, т.е. к наиболее вложенному (на момент парсинга) if.
 - Обратите внимание, что кроме команд теперь есть и выражения, которые возвращают логическое значение и не являются командами. Как они добавлены в грамматику языка? 
 > через гибкость языка python. Вместо просто выполнения команды добавлен возврат результата, а так как обработка блоков кода реализвана рекурсивно, возвращаемое значение идет по рекурсии в место, где будет обработано (по ходу рекурсии может меняться And и др.).
 - Добавьте цикл из ``n`` повторений самостоятельно - :white_check_mark:

Аналогично, нужно добавить реализацию в интерпретатор. Добавим метод ``process_expression(self, e)`` и расширим обработку команд. Один из вариантов [доработки](./karel_control.py).

 - Программа теперь состоит из команды и выражений. Как бы вы реализовали их обработку? 
 > рекурсивно проще всего. Получается машина состояний на стеке (состояние парсера-интерпретатора характеризуется набором и состояниями парсинг-функций на стеке). 

Если все сделано верно, теперь уже можем написать программу обхода лабиринта в поиска сокровищ для произвольного ограниченного стенами лабиринта. Пример программы [здесь](./maze.karel). Не забудьте остановить программу по нахождении сокровища. - :white_check_mark:

## Задача 3 (4 балла)

Теперь посложнее. Нужно добавить подрограммы и пользовательские функции. Сигнатура должна описывать передаваемые параметры - логические выражения. Еще будет полезна отдельная команда на вызов.

 - Есть синтаксис pascal-like, c-like и python-like. Какой вам ближе? 
 > C-like :heart_eyes:
 - Продумайте, как обозначить возвращаемое значение из функции. 
 > Можно реализовать похоже на MATLAB: функция всегда что-то возвращает, нужно это или нет, если имя переменной для возврата значения указано (ввести специальное ключевое слово), то возвращать значение этой переменной, если нет - сентинел-заглушку. Сам возврат через стек - то есть после удаления блока переменных отработавшей функции со стека, добавить на стек блок с одной переменной, который будет обработан после передачи управления.

Реализуем в интерпертаторе. Сохранять место текущего исполнения можно вызывая подпрограмму в текущем месте в самом язке программирования интерпертатора. Вот как [здесь](./karel_structured.py)

 - Как лучше передавать параметры 
 > по значению или по ссылке? - лучше в зависимости от роли параметра. Проще - по значению.
 - Нужен ли стек для реализации подпрограмм? Узнайте, что такое stack frames.Сравните с тем, что уже знаете про область видимости переменных. 
 > стек нужен. Он может быть реализован по-разному, но он нужен для адекватной реализации. Можно сделать без стека, но будет сложно, неуниверсально и некрасиво. Я и про замыкания lambda-функций знаю... Ну, фрейм стека - это, по сути, замыкание, не включающее глобальные переменные только.

Еще стоит добавить команду прерывания цикла ``break``. Она должна приводить к выходу из текущего цикла внутри одной подпрограммы, если такой цикл есть. Приммер реализации без нарушения структуры кода см. [там же](./karel_structured.py).
 
  - Как бы вы реализовали ``goto``? В ранних вариантах Бейсика можно было выходить как за пределы структурного блока, так и за пределы подпрограмм, чем это грозит? 
  > при имеющейся структуре программы goto удобнее всего реализавать через особую логику в исполнении process_statement - передача управления родительской функции с копированием флага и адреса в родительский контекст если в текущем контексте обнаружен соответствующий флаг и адресат для передачи управления не является текущим контекстом ИЛИ смена текущего исполняемого statement если адресат передачи управления совпадает с текущим контекстом. Такая логика позволит передать управление в любое, доступное со стека, место программы. Однако, если надо иметь возможность передавать управление туда, куда программа ещё не дошла (в рамках одного фрейма стека), то можно запустить поиск нужной метки среди стейтментов текущего уровня (т.е. без рекурсии, просто перебор цикла в поисках нужного стейтмента). А передача управления за пределы программы (что невозможно при рассматриваемой реализации), но в общем случае может привести к исполнению данных, не являющихся кодом, или исполнению кода другой программы (если адресное пространство одно и нет защит) или просто к ошибке времени выполнения.
  - Обратите внимание, что мы пока не определяли никакие хранимые данные. ТО есть все данные хранятся на поле в клетку. Если нужно, можно ставить маяки. Как считаете, нужны ли переменные в программе и зачем? 
  > Кое что у робота уже хранится - стек (`ctx`). Маяки нужны для работы goto, без них придётся получать доступ к информации токенизатора о номерах строк или др. информации. В программе для робота переменные могут пригодиться (и на стеке храниться) для реализации боллее умных алгоритмов поиска выхода.

Реализуйте программу поиска сокровищ в лабиринте с применением добавленных конструкций языка. Примера в этот раз нет. - :white_check_mark:
